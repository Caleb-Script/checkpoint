// /services/ticket/prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELED
}

enum PresenceState {
  INSIDE
  OUTSIDE
}

enum RsvpChoice {
  YES
  NO
}

model User {
  id             String   @id @default(cuid())
  keycloakId     String   @unique
  email          String?  @unique
  name           String?
  roles          String[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  guestProfiles  GuestProfile[]
  scanLogs       ScanLog[]
  approvedInvitations Invitation[] @relation("InvitationApprovedBy")
}

model Event {
  id            String    @id @default(cuid())
  name          String
  startsAt      DateTime
  endsAt        DateTime
  allowReEntry  Boolean   @default(true)
  rotateSeconds Int       @default(60)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  seats         Seat[]
  invitations   Invitation[]
  tickets       Ticket[]
  scanLogs      ScanLog[]
}

model Seat {
  id        String  @id @default(cuid())
  eventId   String
  section   String?
  row       String?
  number    String?
  note      String?

  event     Event   @relation(fields: [eventId], references: [id])
  ticket    Ticket?

  @@index([eventId])
}

model GuestProfile {
  id           String   @id @default(cuid())
  primaryEmail String?
  phone        String?
  firstName    String?
  lastName     String?
  userId       String?

  user         User?    @relation(fields: [userId], references: [id])
  invitations  Invitation[]
}

model Invitation {
  id             String            @id @default(cuid())
  eventId        String
  guestProfileId String
  status         InvitationStatus  @default(PENDING)
  messageChannel String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  // RSVP & Approval
  rsvpChoice     RsvpChoice?
  rsvpAt         DateTime?
  approved       Boolean           @default(false)
  approvedAt     DateTime?
  approvedById   String?
  approvedBy     User?             @relation("InvitationApprovedBy", fields: [approvedById], references: [id])

  // ▶️ NEU: “Plus‑Ones” / Weiter‑Einladen
  maxInvitees    Int               @default(0)
  invitedByInvitationId String?
  invitedBy      Invitation?       @relation("InviteChain", fields: [invitedByInvitationId], references: [id])
  invitedChildren Invitation[]     @relation("InviteChain")

  // Optional: sharebarer Kurzcode für personalisierte Links
  shareCode      String?           @unique

  event          Event        @relation(fields: [eventId], references: [id])
  guestProfile   GuestProfile @relation(fields: [guestProfileId], references: [id])
  ticket         Ticket?

  @@index([eventId, status])
  @@index([eventId, rsvpChoice])
  @@index([approved, approvedAt])
}

model Ticket {
  id             String        @id @default(cuid())
  eventId        String
  invitationId   String @unique
  seatId         String?  @unique
  currentState   PresenceState @default(OUTSIDE)
  deviceBoundKey String?
  revoked        Boolean       @default(false)
  lastRotatedAt  DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  event       Event       @relation(fields: [eventId], references: [id])
  invitation  Invitation  @relation(fields: [invitationId], references: [id])
  seat        Seat?       @relation(fields: [seatId], references: [id])
  scanLogs    ScanLog[]
  shareGuard  ShareGuard?

  @@index([eventId])
}

model ScanLog {
  id         String       @id @default(cuid())
  ticketId   String
  eventId    String
  byUserId   String?
  direction  PresenceState
  verdict    String
  gate       String?
  deviceHash String?
  createdAt  DateTime     @default(now())

  ticket Ticket @relation(fields: [ticketId], references: [id])
  event  Event  @relation(fields: [eventId], references: [id])
  byUser User?  @relation(fields: [byUserId], references: [id])

  @@index([eventId, createdAt])
}

model ShareGuard {
  id             String  @id @default(cuid())
  ticketId       String  @unique
  failCount      Int     @default(0)
  lastFailAt     DateTime?
  blockedUntil   DateTime?
  reason         String?

  ticket         Ticket  @relation(fields: [ticketId], references: [id])
}
